Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 1
res.asm



      1	0000			     .model tiny
      2
      3	0000			     .code
      4				     org 100h
      5				     locals @@
      6
      7				     ;------------------------------------------------
      8				     ; CONSTANTS
      9				     ;------------------------------------------------
     10	      =000A		     start_y	 equ 10
     11	      =001E		     start_x	 equ 30
     12
     13	      =000A		     size_x	 equ 10
     14	      =0004		     size_y	 equ 4
     15
     16	      =0070		     color	 equ 070h    ; black on	white
     17
     18	      =0050		     line_len	 equ 80	     ; length of cmd line
     19				     ;------------------------------------------------
     20
     21	0100			     start:
     22	0100  E9 0240			     jmp main
     23
     24				     ;------------------------------------------------
     25				     ; NEW09
     26				     ;
     27				     ; Function	to replace int09
     28				     ; Prints a	table with registers and calls old int09
     29				     ;------------------------------------------------
     30	0103			     new09	 proc
     31	0103  9C				 pushf
     32	0104  55 56 57 06 1E 52	51+		 push bp si di es ds dx	cx bx ax
     33	      53 50
     34
     35	010D  E4 60				 in al,	60h	 ; get pressed button from keyboard
     36	010F  3C 02				 cmp al, 2	 ; if key is not 1 then	do nothing
     37	0111  74 0A				 je @@start_table
     38
     39	0113  3C 03				 cmp al, 3
     40	0115  74 03				 je @@jmp_repair
     41
     42	0117  E9 00C5				 jmp @@old_int	 ; needed because this label is	too far
     43
     44	011A			     @@jmp_repair:
     45	011A  E9 00A1				 jmp @@start_repair
     46
     47	011D			     @@start_table:
     48						 ; for stosw and lodsw
     49	011D  8C C8				 mov ax, cs
     50	011F  8E C0				 mov es, ax
     51	0121  B8 B800				 mov ax, 0b800h
     52	0124  8E D8				 mov ds, ax
     53
     54				     ;------------------------------------------------
     55				     ; Saving old data
     56				     ;------------------------------------------------
     57	      =0088				 @@line_offset = 2*line_len - 2	* size_x - 4
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 2
res.asm



     58
     59	0126  BE 067C				 mov si, 2*((start_y * line_len) + start_x) ; start of frame
     60	0129  BF 01F7r				 mov di, offset	old_screen
     61
     62	012C  B9 0006				 mov cx, size_y	+ 2
     63	012F			     @@copy_frame:
     64	012F  51				 push cx
     65	0130  B9 000C				 mov cx, size_x	+ 2
     66	0133			     @@copy_line:
     67	0133  AD				 lodsw
     68	0134  AB				 stosw
     69	0135  E2 FC				 loop @@copy_line
     70
     71	0137  81 C6 0088			 add si, @@line_offset
     72	013B  59				 pop cx
     73	013C  E2 F1				 loop @@copy_frame
     74
     75						 ; needed for using fuctions, since they use ds	inside
     76	013E  8C C8				 mov ax, cs
     77	0140  8E D8				 mov ds, ax
     78	0142  B8 B800				 mov ax, 0b800h
     79	0145  8E C0				 mov es, ax
     80
     81				     ;------------------------------------------------
     82				     ; Drawing table itself
     83				     ;------------------------------------------------
     84	0147			     @@draw_table:
     85	0147  BE 01EEr				 mov si, offset	frame_borders
     86	014A  E8 0144				 call draw_frame
     87
     88	014D  8B EC				 mov bp, sp  ; needed for addressing since sp doesn't work ¯\_(ツ)_/¯
     89
     90						 ; TODO	is it okay to have copy-paste like this?
     91						 ; TODO	maybe strcpy?
     92	014F  B0 61				 mov al, 'a'
     93	0151  26: A2 0720			 mov es:[2 * ((start_y + 1) * line_len + start_x + 2)],	al
     94	0155  B0 78				 mov al, 'x'
     95	0157  26: A2 0722			 mov es:[2 * ((start_y + 1) * line_len + start_x + 3)],	al
     96	015B  B0 3A				 mov al, ':'
     97	015D  26: A2 0724			 mov es:[2 * ((start_y + 1) * line_len + start_x + 4)],	al
     98	0161  BF 0728				 mov di, 2 * ((start_y + 1) * line_len + start_x + 6)
     99	0164  8B 46 00				 mov ax, ss:[bp]
    100	0167  E8 0159				 call itoa16_resid
    101
    102	016A  B0 62				 mov al, 'b'
    103	016C  26: A2 07C0			 mov es:[2 * ((start_y + 2) * line_len + start_x + 2)],	al
    104	0170  B0 78				 mov al, 'x'
    105	0172  26: A2 07C2			 mov es:[2 * ((start_y + 2) * line_len + start_x + 3)],	al
    106	0176  B0 3A				 mov al, ':'
    107	0178  26: A2 07C4			 mov es:[2 * ((start_y + 2) * line_len + start_x + 4)],	al
    108	017C  BF 07C8				 mov di, 2 * ((start_y + 2) * line_len + start_x + 6)
    109	017F  8B 46 02				 mov ax, ss:[bp	+ 2]
    110	0182  E8 013E				 call itoa16_resid
    111
    112	0185  B0 63				 mov al, 'c'
    113	0187  26: A2 0860			 mov es:[2 * ((start_y + 3) * line_len + start_x + 2)],	al
    114	018B  B0 78				 mov al, 'x'
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 3
res.asm



    115	018D  26: A2 0862			 mov es:[2 * ((start_y + 3) * line_len + start_x + 3)],	al
    116	0191  B0 3A				 mov al, ':'
    117	0193  26: A2 0864			 mov es:[2 * ((start_y + 3) * line_len + start_x + 4)],	al
    118	0197  BF 0868				 mov di, 2 * ((start_y + 3) * line_len + start_x + 6)
    119	019A  8B 46 04				 mov ax, ss:[bp	+ 4]
    120	019D  E8 0123				 call itoa16_resid
    121
    122	01A0  B0 64				 mov al, 'd'
    123	01A2  26: A2 0900			 mov es:[2 * ((start_y + 4) * line_len + start_x + 2)],	al
    124	01A6  B0 78				 mov al, 'x'
    125	01A8  26: A2 0902			 mov es:[2 * ((start_y + 4) * line_len + start_x + 3)],	al
    126	01AC  B0 3A				 mov al, ':'
    127	01AE  26: A2 0904			 mov es:[2 * ((start_y + 4) * line_len + start_x + 4)],	al
    128	01B2  BF 0908				 mov di, 2 * ((start_y + 4) * line_len + start_x + 6)
    129	01B5  8B 46 06				 mov ax, ss:[bp	+ 6]
    130	01B8  E8 0108				 call itoa16_resid
    131
    132	01BB  EB 22 90				 jmp @@old_int
    133
    134				     ;------------------------------------------------
    135				     ; Puts old	data from screen instead of table
    136				     ;------------------------------------------------
    137	01BE			     @@start_repair:
    138	01BE  8C C8				 mov ax, cs
    139	01C0  8E D8				 mov ds, ax
    140	01C2  B8 B800				 mov ax, 0b800h
    141	01C5  8E C0				 mov es, ax
    142
    143	01C7  BF 067C				 mov di, 2*((start_y * line_len) + start_x) ; start of frame
    144	01CA  BE 01F7r				 mov si, offset	old_screen
    145
    146	01CD  B9 0006				 mov cx, size_y	+ 2
    147	01D0			     @@copy_screen:
    148	01D0  51				 push cx
    149	01D1  B9 000C				 mov cx, size_x	+ 2
    150	01D4			     @@copy_sc_line:
    151	01D4  AD				 lodsw
    152	01D5  AB				 stosw
    153	01D6  E2 FC				 loop @@copy_sc_line
    154
    155	01D8  81 C7 0088			 add di, @@line_offset
    156	01DC  59				 pop cx
    157	01DD  E2 F1				 loop @@copy_screen
    158
    159	01DF			     @@old_int:
    160	01DF  58 5B 59 5A 1F 07	5F+		 pop ax	bx cx dx ds es di si bp
    161	      5E 5D
    162	01E8  9D				 popf
    163
    164	01E9  EA				 db 0eah     ; opcode of jmp far
    165	01EA  00000000		     old09	 dd 0	     ; place for ptr to	prev int
    166
    167	01EE  2B 2D 2B 7C 20 7C	2B+		 frame_borders db "+-+|	|+-+"
    168	      2D 2B
    169	01F7  92*(00)				 old_screen  db	2*(size_x+2)*(size_y+2)	+ 2 dup(0)  ; places size_of_table zeroes   +
    170				     (becasue borders are not included in size_x/y and 2* for color)
    171
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 4
res.asm



    172	0289			     new09	 endp
    173
    174				     ;------------------------------------------------
    175				     ; DRAW A LINE
    176				     ; Draws a line in console with args:
    177				     ;	 ah - color
    178				     ;	 cx - len
    179				     ;	 si - addr of 3	byte array
    180				     ;	 di - start of line
    181				     ;	 es = 0b800h
    182				     ;
    183				     ; CHANGED:	ax, cx,	si, di,	es
    184				     ;------------------------------------------------
    185	0289			     draw_line proc
    186					 ; evil	string instructions manipulation
    187	0289  AC			 lodsb
    188	028A  AB			 stosw
    189	028B  AC			 lodsb
    190	028C  F3> AB			 rep stosw
    191	028E  AC			 lodsb
    192	028F  AB			 stosw
    193	0290  C3			 ret
    194	0291			     draw_line endp
    195				     ;------------------------------------------------
    196
    197				     ;------------------------------------------------
    198				     ; DRAW A FRAME
    199				     ; Draws a frame in	console	with args:
    200				     ;	 ah - color	     - using a constant
    201				     ;	 cx - len	     - using a constant
    202				     ;	 si - addr of 9	byte array
    203				     ;	 di - start of line  - using a constant
    204				     ;	 es = 0b800h	     - using a constant
    205				     ;
    206				     ; CHANGED:	ax, cx,	si, di,	es
    207				     ;------------------------------------------------
    208	0291			     draw_frame	proc
    209					 ; placed first	so it doesn't affect ax	reg
    210					 ; because es can only be changed by ax
    211	0291  B8 B800			 mov ax, 0b800h
    212	0294  8E C0			 mov es, ax
    213
    214	0296  B4 70			 mov ah, color
    215	0298  B9 000A			 mov cx, size_x
    216	029B  BF 067C			 mov di, 2*((start_y * line_len) + start_x) ; this formula is coord of frame
    217	029E  E8 FFE8			 call draw_line
    218
    219	      =0088			 @@line_offset = 2*line_len - 2	* size_x - 4
    220
    221	02A1  B9 0004			 mov cx, size_y
    222	02A4				 @@lines:
    223					     ; TODO is it good to manipulate cx	and stk	like this?
    224	02A4  51			     push cx
    225	02A5  81 C7 0088		     add di, @@line_offset
    226	02A9  B9 000A			     mov cx, size_x
    227	02AC  E8 FFDA			     call draw_line
    228	02AF  83 C6 FD			     add si, -3	     ; to return to begin of table
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 5
res.asm



    229	02B2  59			     pop cx
    230	02B3  E2 EF			     loop @@lines
    231
    232					 ; print bottom	line
    233	02B5  83 C6 03			 add si, 3
    234	02B8  81 C7 0088		 add di, @@line_offset
    235	02BC  B9 000A			 mov cx, size_x
    236	02BF  E8 FFC7			 call draw_line
    237
    238	02C2  C3			 ret
    239	02C3			     draw_frame	endp
    240
    241				     ;------------------------------------------------
    242				     ; ITOA16_RESID
    243				     ; Translates unsigned bx number to	str pointed by di with base 2^cl for resident purposes
    244				     ; It doesn't place	\0 or $	at the end
    245				     ; TODO make program always	fill four symbols
    246				     ;	 di - ptr of str to be written
    247				     ;	 ax - number to	be translated
    248				     ;	 es - segment of memory	to write
    249				     ; CHANGED:	bx, dx,	di, si
    250				     ;------------------------------------------------
    251	02C3			     itoa16_resid proc
    252	02C3  8B D8			 mov bx, ax
    253	02C5  D1 EB D1 EB D1 EB	D1+	 shr bx, 12
    254	      EB D1 EB D1 EB D1	EB+
    255	      D1 EB D1 EB D1 EB	D1+
    256	      EB D1 EB
    257	02DD  2E: 8A 9F	0333r		 mov bl, cs:[bx	+ offset XlatTable]
    258	02E2  26: 88 1D			 mov es:[di], bl
    259	02E5  83 C7 02			 add di, 2
    260
    261	02E8  8B D8			 mov bx, ax
    262	02EA  81 E3 0F00		 and bx, 0F00h
    263	02EE  D1 EB D1 EB D1 EB	D1+	 shr bx, 8
    264	      EB D1 EB D1 EB D1	EB+
    265	      D1 EB
    266	02FE  2E: 8A 9F	0333r		 mov bl, cs:[bx	+ offset XlatTable]
    267	0303  26: 88 1D			 mov es:[di], bl
    268	0306  83 C7 02			 add di, 2
    269
    270	0309  8B D8			 mov bx, ax
    271	030B  81 E3 00F0		 and bx, 0F0h
    272	030F  D1 EB D1 EB D1 EB	D1+	 shr bx, 4
    273	      EB
    274	0317  2E: 8A 9F	0333r		 mov bl, cs:[bx	+ offset XlatTable]
    275	031C  26: 88 1D			 mov es:[di], bl
    276	031F  83 C7 02			 add di, 2
    277
    278	0322  8B D8			 mov bx, ax
    279	0324  83 E3 0F			 and bx, 0Fh
    280	0327  2E: 8A 9F	0333r		 mov bl, cs:[bx	+ offset XlatTable]
    281	032C  26: 88 1D			 mov es:[di], bl
    282	032F  83 C7 02			 add di, 2
    283
    284	0332			     @@ret:
    285	0332  C3			 ret
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 6
res.asm



    286
    287	0333  30 31 32 33 34 35	36+	 XlatTable db "0123456789ABCDEF"
    288	      37 38 39 41 42 43	44+
    289	      45 46
    290
    291	0343			     itoa16_resid endp
    292
    293	0343			     main:
    294	0343  33 DB			     xor bx, bx
    295	0345  8E C3			     mov es, bx	     ; es = 0
    296	0347  BB 0024			     mov bx, 09h*4   ; *4 is needed because every int ptr is 4 bytes
    297
    298					     ; saves 4 bytes of	ptr to int func
    299	034A  26: 8B 07			     mov ax, es:[bx]
    300	034D  2E: A3 01EAr		     mov word ptr cs:[old09], ax
    301	0351  26: 8B 47	02		     mov ax, es:[bx+2]
    302	0355  2E: A3 01ECr		     mov word ptr cs:[old09+2],	ax
    303
    304	0359  B8 0103r			     mov ax, offset new09
    305	035C  26: 89 07			     mov es:[bx], ax
    306	035F  26: 8C 4F	02		     mov es:[bx+2], cs
    307
    308					     ; jmp new09
    309
    310	0363  BA 0343r			     mov dx, offset main     ; leaving as resident, offset main	is enough since	interruption+
    311				     is	before
    312	0366  D1 E2 D1 E2 D1 E2	D1+	     shl dx, 4
    313	      E2
    314	036E  42			     inc dx
    315	036F  B8 3100			     mov ax, 3100h
    316	0372  CD 21			     int 21h
    317
    318				     end start
Turbo Assembler	 Version 4.1	    03/11/22 23:20:14	    Page 7
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/11/22"
??FILENAME			  Text	 "res	  "
??TIME				  Text	 "23:20:14"
??VERSION			  Number 040A
@32BIT				  Text	 0
@@COPY_FRAME			  Near	 DGROUP:012F
@@COPY_LINE			  Near	 DGROUP:0133
@@COPY_SCREEN			  Near	 DGROUP:01D0
@@COPY_SC_LINE			  Near	 DGROUP:01D4
@@DRAW_TABLE			  Near	 DGROUP:0147
@@JMP_REPAIR			  Near	 DGROUP:011A
@@LINES				  Near	 DGROUP:02A4
@@LINE_OFFSET			  Number 0088
@@LINE_OFFSET			  Number 0088
@@OLD_INT			  Near	 DGROUP:01DF
@@RET				  Near	 DGROUP:0332
@@START_REPAIR			  Near	 DGROUP:01BE
@@START_TABLE			  Near	 DGROUP:011D
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 RES
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
COLOR				  Number 0070
DRAW_FRAME			  Near	 DGROUP:0291
DRAW_LINE			  Near	 DGROUP:0289
FRAME_BORDERS			  Byte	 DGROUP:01EE
ITOA16_RESID			  Near	 DGROUP:02C3
LINE_LEN			  Number 0050
MAIN				  Near	 DGROUP:0343
NEW09				  Near	 DGROUP:0103
OLD09				  Dword	 DGROUP:01EA
OLD_SCREEN			  Byte	 DGROUP:01F7
SIZE_X				  Number 000A
SIZE_Y				  Number 0004
START				  Near	 DGROUP:0100
START_X				  Number 001E
START_Y				  Number 000A
XLATTABLE			  Byte	 DGROUP:0333

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  0374 Word	  Public  CODE
