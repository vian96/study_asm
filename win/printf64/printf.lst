     1                                  global _start
     2                                  
     3                                  extern GetStdHandle
     4                                  extern WriteConsoleA
     5                                  extern ExitProcess
     6                                  
     7                                  ; First arg is str and second is length
     8                                  %macro WRITE 2
     9                                  ; WriteConsole( STD_OUTPUT_HANDLE, strbuffer, numofchar, numwritten, double 0)
    10                                          push    dword 0         
    11                                          push    numCharsWritten
    12                                          push    dword %2    
    13                                          push    dword %1             
    14                                          push    dword    [STDOutputHandle]
    15                                          call    WriteConsoleA
    16                                  %endmacro ; WRITE
    17                                  
    18                                  %define DEB     WRITE DEBSTR, 4
    19                                  
    20                                  section .data
    21 00000000 78656C6C6F2C20776F-             str:     db 'xello, world!', 0x0D, 0x0A, 0 ; \r\n\0
    21 00000009 726C64210D0A00     
    22                                          strLen:  equ $-str
    23                                  
    24                                  section .bss
    25 00000000 ????????                        numCharsWritten     resd 1
    26 00000004 ????????                        STDOutputHandle     resd 1
    27                                  
    28 00000008 <res 28h>                       itoaBuff            resb 40 ; because 32 + some buffer space
    29 00000030 ????????                        ret_addr            resd 1
    30                                  
    31                                  
    32                                  section .text
    33                                  
    34                                  %include "itoa.asm"
    35                              <1> ;------------------------------------------------
    36                              <1> ; ITOA
    37                              <1> ; Translates unsigned bx number to str pointed by di with base cx and places $ at the end
    38                              <1> ;   edi - ptr of str to be written
    39                              <1> ;   ecx - base
    40                              <1> ;   eax - number to be translated
    41                              <1> ; CHANGED: ebx, edx, edi, esi
    42                              <1> ; RETURNED: eax - length
    43                              <1> ;------------------------------------------------
    44                              <1> itoa:
    45 00000000 39C8                <1>     cmp eax, ecx
    46 00000002 7F12                <1>     jg .main_itoa
    47                              <1> 
    48 00000004 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
    49 0000000A 8817                <1>     mov [edi], dl
    50 0000000C C6470100            <1>     mov byte [edi+1], 0
    51 00000010 B801000000          <1>     mov eax, 1
    52 00000015 C3                  <1>     ret
    53                              <1> 
    54                              <1> .main_itoa:
    55 00000016 89FE                <1>     mov esi, edi
    56                              <1> 
    57                              <1>     .loop:
    58 00000018 BA00000000          <1>         mov edx, 0
    59 0000001D F7F1                <1>         div ecx              ; eax = edx:eax div ecx, edx = edx:eax % ecx
    60 0000001F 89D3                <1>         mov ebx, edx
    61 00000021 8A93[A4000000]      <1>         mov dl, [ebx + XlatTable]
    62                              <1> 
    63 00000027 8817                <1>         mov [edi], dl
    64 00000029 47                  <1>         inc edi
    65                              <1> 
    66 0000002A 83F800              <1>         cmp eax, 0
    67 0000002D 7402                <1>         je .end_loop
    68 0000002F EBE7                <1>     jmp .loop
    69                              <1> 
    70                              <1> .end_loop:
    71 00000031 89F9                <1>     mov ecx, edi
    72 00000033 29F1                <1>     sub ecx, esi
    73 00000035 D1E9                <1>     shr ecx, 1
    74 00000037 C60700              <1>     mov byte [edi], 0
    75 0000003A 89FA                <1>     mov edx, edi
    76 0000003C 29F2                <1>     sub edx, esi
    77 0000003E 4F                  <1>     dec edi
    78                              <1> 
    79                              <1>     .reverse_ans:
    80 0000003F 8A07                <1>         mov al, [edi]
    81 00000041 8606                <1>         xchg [esi], al
    82 00000043 8807                <1>         mov [edi], al
    83                              <1> 
    84 00000045 4F                  <1>         dec edi
    85 00000046 46                  <1>         inc esi
    86 00000047 E2F6                <1>     loop .reverse_ans
    87                              <1> 
    88 00000049 89D0                <1>     mov eax, edx ; returned value is length
    89 0000004B C3                  <1>     ret
    90                              <1> 
    91                              <1> ; end of itoa
    92                              <1> 
    93                              <1> 
    94                              <1> ;------------------------------------------------
    95                              <1> ; ITOA2N
    96                              <1> ; Translates unsigned bx number to str pointed by di with base 2^cl and places $ at the end
    97                              <1> ;   di - ptr of str to be written
    98                              <1> ;   cl - power of base
    99                              <1> ;   ax - number to be translated
   100                              <1> ;   bh = 0
   101                              <1> ; CHANGED: bx, dx, di, si
   102                              <1> ;------------------------------------------------
   103                              <1> itoa2n:
   104 0000004C BB01000000          <1>     mov ebx, 1
   105 00000051 D3E3                <1>     shl ebx, cl
   106 00000053 39D8                <1>     cmp eax, ebx
   107 00000055 7F12                <1>     jg .main_itoa2n
   108                              <1> 
   109 00000057 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
   110 0000005D 8817                <1>     mov [edi], dl
   111 0000005F C6470100            <1>     mov byte [edi+1], 0
   112 00000063 B801000000          <1>     mov eax, 1
   113 00000068 C3                  <1>     ret
   114                              <1> 
   115                              <1> .main_itoa2n:
   116 00000069 89FE                <1>     mov esi, edi
   117 0000006B BA01000000          <1>     mov edx, 1
   118 00000070 D3E2                <1>     shl edx, cl
   119 00000072 4A                  <1>     dec edx                  ; dx = 2^cl - 1
   120                              <1> 
   121                              <1>     .loop:
   122 00000073 89C3                <1>         mov ebx, eax
   123 00000075 21D3                <1>         and ebx, edx          ; bx = ax % 2^cl
   124 00000077 D3E8                <1>         shr eax, cl          ; ax = ax / 2^cl
   125                              <1> 
   126 00000079 8A9B[A4000000]      <1>         mov bl, [ebx + XlatTable]
   127 0000007F 881F                <1>         mov [edi], bl
   128 00000081 47                  <1>         inc edi
   129                              <1> 
   130 00000082 83F800              <1>         cmp eax, 0
   131 00000085 7402                <1>         je .end_loop
   132 00000087 EBEA                <1>     jmp .loop
   133                              <1> 
   134                              <1>     ; TODO is it okay to have copypaste like this?
   135                              <1>     .end_loop:
   136 00000089 89F9                <1>     mov ecx, edi
   137 0000008B 29F1                <1>     sub ecx, esi
   138 0000008D D1E9                <1>     shr ecx, 1
   139 0000008F C60700              <1>     mov byte [edi], 0
   140 00000092 89FA                <1>     mov edx, edi
   141 00000094 29F2                <1>     sub edx, esi
   142 00000096 4F                  <1>     dec edi
   143                              <1> 
   144                              <1>     .reverse:
   145 00000097 8A07                <1>         mov al, [edi]
   146 00000099 8606                <1>         xchg [esi], al
   147 0000009B 8807                <1>         mov [edi], al
   148                              <1> 
   149 0000009D 4F                  <1>         dec edi
   150 0000009E 46                  <1>         inc esi
   151 0000009F E2F6                <1>     loop .reverse
   152                              <1> 
   153 000000A1 89D0                <1>     mov eax, edx ; returned value is length
   154 000000A3 C3                  <1>     ret
   155                              <1> 
   156                              <1> ; end of itoa2n
   157                              <1> 
   158 000000A4 303132333435363738- <1>     XlatTable db '0123456789ABCDEF'
   158 000000AD 39414243444546      <1>
    35                                  
    36                                  ;------------------------------------------------
    37                                  ; STRLEN
    38                                  ; edi - source of str
    39                                  ; CHANGED: ecx, edi, eax, ebx
    40                                  ; RETURN: eax - len
    41                                  ;------------------------------------------------
    42                                  strlen:
    43                                      ; TODO check flags of direction
    44 000000B4 89FB                        mov     ebx, edi
    45 000000B6 30C0                        xor     al, al  
    46 000000B8 B9FFFFFFFF                  mov     ecx, 0xffffffff
    47                                  
    48 000000BD F2AE                        repne   scasb   ; while [edi] != al
    49                                  
    50 000000BF 29DF                        sub     edi, ebx     
    51 000000C1 89F8                        mov     eax, edi     
    52 000000C3 48                          dec eax
    53                                  
    54 000000C4 C3                          ret         
    55                                  ; end of strlen 
    56                                  
    57                                  ;------------------------------------------------
    58                                  ; MACRO FOR PRINTF
    59                                  ; Writes ecx symbols from esi and see code, its simple
    60                                  ;------------------------------------------------
    61                                  %macro WRITE_BUF 0
    62                                      WRITE edi, ecx
    63                                      xor ecx, ecx
    64                                      mov edi, esi
    65                                      add edi, 2      ; to move from % to actual string
    66                                  %endmacro ; WRITE_BUF
    67                                  
    68                                  ;------------------------------------------------
    69                                  ; PRINTF
    70                                  ; 
    71                                  ; CHANGED: esi, eax, dl, ecx (ret), ebx
    72                                  ;------------------------------------------------
    73                                  printf:
    74                                      push r9
    74          ******************       error: instruction not supported in 32-bit mode
    75                                      ; si is where we read string
    76 000000C5 59                          pop     ecx
    77 000000C6 890D[30000000]              mov     [ret_addr], ecx
    78 000000CC 5E                          pop     esi
    79 000000CD 89F7                        mov     edi, esi
    80 000000CF 4E                          dec     esi      ; useful because you do not need to inc it befoure calling loop
    81 000000D0 31C9                        xor ecx, ecx
    82                                  
    83                                      .printf_loop:
    84 000000D2 46                              inc     esi
    85 000000D3 8A06                            mov     al, [esi]
    86 000000D5 3C25                            cmp     al, '%'
    87 000000D7 7434                            je      .codes
    88                                  
    89 000000D9 3C00                            cmp     al, 0
    90 000000DB 7403                            je      .ret
    91                                  
    92 000000DD 41                              inc ecx
    93 000000DE EBF2                            jmp     .printf_loop
    94                                  
    95                                  .ret:
    96                                      WRITE_BUF
    62                              <1>  WRITE edi, ecx
     9                              <2> 
    10 000000E0 6A00                <2>  push dword 0
    11 000000E2 68[00000000]        <2>  push numCharsWritten
    12 000000E7 51                  <2>  push dword %2
    13 000000E8 57                  <2>  push dword %1
    14 000000E9 FF35[04000000]      <2>  push dword [STDOutputHandle]
    15 000000EF E8(00000000)        <2>  call WriteConsoleA
    63 000000F4 31C9                <1>  xor ecx, ecx
    64 000000F6 89F7                <1>  mov edi, esi
    65 000000F8 83C702              <1>  add edi, 2
    97 000000FB 8B0D[30000000]              mov     ecx, [ret_addr]
    98 00000101 51                          push    ecx
    99 00000102 C3                          ret
   100                                  
   101                                  .jmp_percent:
   102 00000103 E9BE010000                  jmp     .percent
   103                                  
   104                                  .jmp_default:
   105 00000108 E9DE010000                  jmp     .default
   106                                  
   107                                  .codes:
   108                                      WRITE_BUF
    62                              <1>  WRITE edi, ecx
     9                              <2> 
    10 0000010D 6A00                <2>  push dword 0
    11 0000010F 68[00000000]        <2>  push numCharsWritten
    12 00000114 51                  <2>  push dword %2
    13 00000115 57                  <2>  push dword %1
    14 00000116 FF35[04000000]      <2>  push dword [STDOutputHandle]
    15 0000011C E8(00000000)        <2>  call WriteConsoleA
    63 00000121 31C9                <1>  xor ecx, ecx
    64 00000123 89F7                <1>  mov edi, esi
    65 00000125 83C702              <1>  add edi, 2
   109                                  
   110 00000128 46                          inc     esi
   111 00000129 8A06                        mov     al, [esi]
   112                                  
   113 0000012B 3C25                        cmp     al, '%'
   114 0000012D 74D4                        je      .jmp_percent
   115 0000012F 3C62                        cmp     al, 'b'
   116 00000131 7CD5                        jl      .jmp_default    ; less than 'b'
   117 00000133 3C78                        cmp     al, 'x'
   118 00000135 7FD1                        jg      .jmp_default    ; more than 'x'
   119                                  
   120 00000137 2C62                        sub     al, 'b'
   121 00000139 31DB                        xor     ebx, ebx
   122 0000013B 88C3                        mov     bl, al
   123                                      ; ebx = 4*al
   124 0000013D 01DB                        add     ebx, ebx
   125 0000013F 01DB                        add     ebx, ebx
   126                                  
   127 00000141 8B9B[49010000]              mov     ebx, [ebx + .jmp_table]
   128 00000147 FFE3                        jmp     ebx
   129                                  
   130                                  .jmp_table:
   131                                      ; hardcoded jmp table
   132 00000149 [D8010000]                  dd      .bin 
   133 0000014D [77020000]                  dd      .char
   134 00000151 [A5010000]                  dd      .dec
   135 00000155 [EB020000]-                 dd      10 dup(.default)
   135 00000159 [EB020000]-        
   135 0000015D [EB020000]-        
   135 00000161 [EB020000]-        
   135 00000165 [EB020000]-        
   135 00000169 [EB020000]-        
   135 0000016D [EB020000]-        
   135 00000171 [EB020000]-        
   135 00000175 [EB020000]-        
   135 00000179 [EB020000]         
   136 0000017D [0D020000]                  dd      .oct
   137 00000181 [EB020000]-                 dd      3 dup(.default)
   137 00000185 [EB020000]-        
   137 00000189 [EB020000]         
   138 0000018D [9D020000]                  dd      .str
   139 00000191 [EB020000]-                 dd      4 dup(.default)
   139 00000195 [EB020000]-        
   139 00000199 [EB020000]-        
   139 0000019D [EB020000]         
   140 000001A1 [42020000]                  dd      .hex
   141                                  
   142                                  .dec:
   143 000001A5 58                          pop     eax
   144 000001A6 56                          push    esi
   145 000001A7 57                          push    edi
   146 000001A8 51                          push    ecx
   147                                  
   148 000001A9 BF[08000000]                mov     edi, itoaBuff
   149 000001AE B90A000000                  mov     ecx, 10
   150 000001B3 E848FEFFFF                  call    itoa
   151                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001B8 6A00                <1>  push dword 0
    11 000001BA 68[00000000]        <1>  push numCharsWritten
    12 000001BF 50                  <1>  push dword %2
    13 000001C0 68[08000000]        <1>  push dword %1
    14 000001C5 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001CB E8(00000000)        <1>  call WriteConsoleA
   152                                  
   153 000001D0 59                          pop     ecx
   154 000001D1 5F                          pop     edi
   155 000001D2 5E                          pop     esi
   156 000001D3 E9FAFEFFFF                  jmp     .printf_loop
   157                                  
   158                                  .bin:
   159 000001D8 58                          pop     eax
   160 000001D9 56                          push    esi
   161 000001DA 57                          push    edi
   162 000001DB 51                          push    ecx
   163                                  
   164 000001DC BF[08000000]                mov     edi, itoaBuff
   165 000001E1 B901000000                  mov     ecx, 1
   166 000001E6 30FF                        xor     bh, bh
   167 000001E8 E85FFEFFFF                  call    itoa2n
   168                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001ED 6A00                <1>  push dword 0
    11 000001EF 68[00000000]        <1>  push numCharsWritten
    12 000001F4 50                  <1>  push dword %2
    13 000001F5 68[08000000]        <1>  push dword %1
    14 000001FA FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000200 E8(00000000)        <1>  call WriteConsoleA
   169                                  
   170 00000205 59                          pop     ecx
   171 00000206 5F                          pop     edi
   172 00000207 5E                          pop     esi
   173 00000208 E9C5FEFFFF                  jmp     .printf_loop
   174                                  
   175                                  .oct:
   176 0000020D 58                          pop     eax
   177 0000020E 56                          push    esi
   178 0000020F 57                          push    edi
   179 00000210 51                          push    ecx
   180                                  
   181 00000211 BF[08000000]                mov     edi, itoaBuff
   182 00000216 B903000000                  mov     ecx, 3
   183 0000021B 30FF                        xor     bh, bh
   184 0000021D E82AFEFFFF                  call    itoa2n
   185                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000222 6A00                <1>  push dword 0
    11 00000224 68[00000000]        <1>  push numCharsWritten
    12 00000229 50                  <1>  push dword %2
    13 0000022A 68[08000000]        <1>  push dword %1
    14 0000022F FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000235 E8(00000000)        <1>  call WriteConsoleA
   186                                  
   187 0000023A 59                          pop     ecx
   188 0000023B 5F                          pop     edi
   189 0000023C 5E                          pop     esi
   190 0000023D E990FEFFFF                  jmp     .printf_loop
   191                                  
   192                                  .hex:
   193 00000242 58                          pop     eax
   194 00000243 56                          push    esi
   195 00000244 57                          push    edi
   196 00000245 51                          push    ecx
   197                                  
   198 00000246 BF[08000000]                mov     edi, itoaBuff
   199 0000024B B904000000                  mov     ecx, 4
   200 00000250 30FF                        xor     bh, bh
   201 00000252 E8F5FDFFFF                  call    itoa2n
   202                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000257 6A00                <1>  push dword 0
    11 00000259 68[00000000]        <1>  push numCharsWritten
    12 0000025E 50                  <1>  push dword %2
    13 0000025F 68[08000000]        <1>  push dword %1
    14 00000264 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 0000026A E8(00000000)        <1>  call WriteConsoleA
   203                                  
   204 0000026F 59                          pop     ecx
   205 00000270 5F                          pop     edi
   206 00000271 5E                          pop     esi
   207 00000272 E95BFEFFFF                  jmp     .printf_loop
   208                                  
   209                                  .char:
   210 00000277 58                          pop     eax
   211 00000278 A2[08000000]                mov     [itoaBuff], al
   212 0000027D 51                          push    ecx
   213                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 0000027E 6A00                <1>  push dword 0
    11 00000280 68[00000000]        <1>  push numCharsWritten
    12 00000285 6A01                <1>  push dword %2
    13 00000287 68[08000000]        <1>  push dword %1
    14 0000028C FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000292 E8(00000000)        <1>  call WriteConsoleA
   214 00000297 59                          pop     ecx
   215 00000298 E935FEFFFF                  jmp     .printf_loop
   216                                  
   217                                  .str:
   218 0000029D 58                          pop     eax
   219 0000029E 56                          push    esi
   220 0000029F 57                          push    edi
   221 000002A0 51                          push    ecx
   222                                  
   223 000002A1 89C6                        mov     esi, eax
   224 000002A3 89C7                        mov     edi, eax
   225 000002A5 E80AFEFFFF                  call    strlen
   226                                  
   227                                      WRITE   esi, eax
     9                              <1> 
    10 000002AA 6A00                <1>  push dword 0
    11 000002AC 68[00000000]        <1>  push numCharsWritten
    12 000002B1 50                  <1>  push dword %2
    13 000002B2 56                  <1>  push dword %1
    14 000002B3 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002B9 E8(00000000)        <1>  call WriteConsoleA
   228                                  
   229 000002BE 59                          pop     ecx
   230 000002BF 5F                          pop     edi
   231 000002C0 5E                          pop     esi
   232                                  
   233 000002C1 E90CFEFFFF                  jmp     .printf_loop
   234                                  
   235                                  .percent:
   236 000002C6 C605[08000000]25            mov     byte [itoaBuff], '%'
   237                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 000002CD 6A00                <1>  push dword 0
    11 000002CF 68[00000000]        <1>  push numCharsWritten
    12 000002D4 6A01                <1>  push dword %2
    13 000002D6 68[08000000]        <1>  push dword %1
    14 000002DB FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002E1 E8(00000000)        <1>  call WriteConsoleA
   238 000002E6 E9E7FDFFFF                  jmp     .printf_loop
   239                                  
   240                                  .default:
   241 000002EB E9E2FDFFFF                  jmp     .printf_loop
   242                                  
   243                                  ; end of printf
   244                                  
   245                                  _start:
   246                                  
   247                                      ; GetStdHandle( STD_OUTPUT_HANDLE )
   248 000002F0 6AF5                        push    dword -11
   249 000002F2 E8(00000000)                call    GetStdHandle ; returns in eax
   250 000002F7 A3[04000000]                mov     [STDOutputHandle], eax
   251                                  
   252 000002FC 6A11                        push    dword 17
   253 000002FE 68DE000000                  push    dword 0DEh
   254 00000303 68[69030000]                push    dword  str_wr
   255 00000308 6A6A                        push    dword 'j'
   256 0000030A 6A06                        push    dword 6
   257 0000030C 6841050000                  push    dword 1345
   258 00000311 68[22030000]                push    dword  str_to_printf
   259 00000316 E8AAFDFFFF                  call    printf
   260                                  
   261                                      ; ExitProcess( 0 )
   262 0000031B 6A00                        push    dword 0   
   263 0000031D E8(00000000)                call    ExitProcess
   264                                  
   265 00000322 5052494E5446464646-         str_to_printf db "PRINTFFFF %d was not %b and %c so it is %s and %x but not %o (not 0)", 10, "a", 0
   265 0000032B 20256420776173206E-
   265 00000334 6F7420256220616E64-
   265 0000033D 20256320736F206974-
   265 00000346 20697320257320616E-
   265 0000034F 642025782062757420-
   265 00000358 6E6F7420256F20286E-
   265 00000361 6F742030290A6100   
   266 00000369 736F6D652073747200          str_wr        db "some str", 0
   267                                  
   268 00000372 4445420A00                  DEBSTR db "DEB", 10, 0
