     1                                  global _start
     2                                  
     3                                  extern GetStdHandle
     4                                  extern WriteConsoleA
     5                                  extern ExitProcess
     6                                  
     7                                  ; First arg is str and second is length
     8                                  %macro WRITE 2
     9                                  ; WriteConsole( STD_OUTPUT_HANDLE, strbuffer, numofchar, numwritten, double 0)
    10                                          push    dword 0         
    11                                          push    numCharsWritten
    12                                          push    dword %2    
    13                                          push    dword %1             
    14                                          push    dword    [STDOutputHandle]
    15                                          call    WriteConsoleA
    16                                  %endmacro ; WRITE
    17                                  
    18                                  %define DEB     WRITE DEBSTR, 4
    19                                  
    20                                  section .data
    21 00000000 78656C6C6F2C20776F-             str:     db 'xello, world!', 0x0D, 0x0A, 0 ; \r\n\0
    21 00000009 726C64210D0A00     
    22                                          strLen:  equ $-str
    23                                  
    24                                  section .bss
    25 00000000 ????????                        numCharsWritten     resd 1
    26 00000004 ????????                        STDOutputHandle     resd 1
    27                                  
    28 00000008 <res 28h>                       itoaBuff            resb 40 ; because 32 + some buffer space
    29 00000030 ????????                        ret_addr            resd 1
    30                                  
    31                                  
    32                                  section .text
    33                                  
    34                                  %include "itoa.asm"
    35                              <1> ;------------------------------------------------
    36                              <1> ; ITOA
    37                              <1> ; Translates unsigned bx number to str pointed by di with base cx and places $ at the end
    38                              <1> ;   edi - ptr of str to be written
    39                              <1> ;   ecx - base
    40                              <1> ;   eax - number to be translated
    41                              <1> ; CHANGED: ebx, edx, edi, esi
    42                              <1> ; RETURNED: eax - length
    43                              <1> ;------------------------------------------------
    44                              <1> itoa:
    45 00000000 39C8                <1>     cmp eax, ecx
    46 00000002 7F12                <1>     jg .main_itoa
    47                              <1> 
    48 00000004 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
    49 0000000A 8817                <1>     mov [edi], dl
    50 0000000C C6470100            <1>     mov byte [edi+1], 0
    51 00000010 B801000000          <1>     mov eax, 1
    52 00000015 C3                  <1>     ret
    53                              <1> 
    54                              <1> .main_itoa:
    55 00000016 89FE                <1>     mov esi, edi
    56                              <1> 
    57                              <1>     .loop:
    58 00000018 BA00000000          <1>         mov edx, 0
    59 0000001D F7F1                <1>         div ecx              ; eax = edx:eax div ecx, edx = edx:eax % ecx
    60 0000001F 89D3                <1>         mov ebx, edx
    61 00000021 8A93[A4000000]      <1>         mov dl, [ebx + XlatTable]
    62                              <1> 
    63 00000027 8817                <1>         mov [edi], dl
    64 00000029 47                  <1>         inc edi
    65                              <1> 
    66 0000002A 83F800              <1>         cmp eax, 0
    67 0000002D 7402                <1>         je .end_loop
    68 0000002F EBE7                <1>     jmp .loop
    69                              <1> 
    70                              <1> .end_loop:
    71 00000031 89F9                <1>     mov ecx, edi
    72 00000033 29F1                <1>     sub ecx, esi
    73 00000035 D1E9                <1>     shr ecx, 1
    74 00000037 C60700              <1>     mov byte [edi], 0
    75 0000003A 89FA                <1>     mov edx, edi
    76 0000003C 29F2                <1>     sub edx, esi
    77 0000003E 4F                  <1>     dec edi
    78                              <1> 
    79                              <1>     .reverse_ans:
    80 0000003F 8A07                <1>         mov al, [edi]
    81 00000041 8606                <1>         xchg [esi], al
    82 00000043 8807                <1>         mov [edi], al
    83                              <1> 
    84 00000045 4F                  <1>         dec edi
    85 00000046 46                  <1>         inc esi
    86 00000047 E2F6                <1>     loop .reverse_ans
    87                              <1> 
    88 00000049 89D0                <1>     mov eax, edx ; returned value is length
    89 0000004B C3                  <1>     ret
    90                              <1> 
    91                              <1> ; end of itoa
    92                              <1> 
    93                              <1> 
    94                              <1> ;------------------------------------------------
    95                              <1> ; ITOA2N
    96                              <1> ; Translates unsigned bx number to str pointed by di with base 2^cl and places $ at the end
    97                              <1> ;   di - ptr of str to be written
    98                              <1> ;   cl - power of base
    99                              <1> ;   ax - number to be translated
   100                              <1> ;   bh = 0
   101                              <1> ; CHANGED: bx, dx, di, si
   102                              <1> ;------------------------------------------------
   103                              <1> itoa2n:
   104 0000004C BB01000000          <1>     mov ebx, 1
   105 00000051 D3E3                <1>     shl ebx, cl
   106 00000053 39D8                <1>     cmp eax, ebx
   107 00000055 7F12                <1>     jg .main_itoa2n
   108                              <1> 
   109 00000057 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
   110 0000005D 8817                <1>     mov [edi], dl
   111 0000005F C6470100            <1>     mov byte [edi+1], 0
   112 00000063 B801000000          <1>     mov eax, 1
   113 00000068 C3                  <1>     ret
   114                              <1> 
   115                              <1> .main_itoa2n:
   116 00000069 89FE                <1>     mov esi, edi
   117 0000006B BA01000000          <1>     mov edx, 1
   118 00000070 D3E2                <1>     shl edx, cl
   119 00000072 4A                  <1>     dec edx                  ; dx = 2^cl - 1
   120                              <1> 
   121                              <1>     .loop:
   122 00000073 89C3                <1>         mov ebx, eax
   123 00000075 21D3                <1>         and ebx, edx          ; bx = ax % 2^cl
   124 00000077 D3E8                <1>         shr eax, cl          ; ax = ax / 2^cl
   125                              <1> 
   126 00000079 8A9B[A4000000]      <1>         mov bl, [ebx + XlatTable]
   127 0000007F 881F                <1>         mov [edi], bl
   128 00000081 47                  <1>         inc edi
   129                              <1> 
   130 00000082 83F800              <1>         cmp eax, 0
   131 00000085 7402                <1>         je .end_loop
   132 00000087 EBEA                <1>     jmp .loop
   133                              <1> 
   134                              <1>     ; TODO is it okay to have copypaste like this?
   135                              <1>     .end_loop:
   136 00000089 89F9                <1>     mov ecx, edi
   137 0000008B 29F1                <1>     sub ecx, esi
   138 0000008D D1E9                <1>     shr ecx, 1
   139 0000008F C60700              <1>     mov byte [edi], 0
   140 00000092 89FA                <1>     mov edx, edi
   141 00000094 29F2                <1>     sub edx, esi
   142 00000096 4F                  <1>     dec edi
   143                              <1> 
   144                              <1>     .reverse:
   145 00000097 8A07                <1>         mov al, [edi]
   146 00000099 8606                <1>         xchg [esi], al
   147 0000009B 8807                <1>         mov [edi], al
   148                              <1> 
   149 0000009D 4F                  <1>         dec edi
   150 0000009E 46                  <1>         inc esi
   151 0000009F E2F6                <1>     loop .reverse
   152                              <1> 
   153 000000A1 89D0                <1>     mov eax, edx ; returned value is length
   154 000000A3 C3                  <1>     ret
   155                              <1> 
   156                              <1> ; end of itoa2n
   157                              <1> 
   158 000000A4 303132333435363738- <1>     XlatTable db '0123456789ABCDEF'
   158 000000AD 39414243444546      <1>
    35                                  
    36                                  ;------------------------------------------------
    37                                  ; STRLEN
    38                                  ; edi - source of str
    39                                  ; CHANGED: ecx, edi, eax, ebx
    40                                  ; RETURN: eax - len
    41                                  ;------------------------------------------------
    42                                  strlen:
    43                                      ; TODO check flags of direction
    44 000000B4 89FB                        mov     ebx, edi
    45 000000B6 30C0                        xor     al, al  
    46 000000B8 B9FFFFFFFF                  mov     ecx, 0xffffffff
    47                                  
    48 000000BD F2AE                        repne   scasb   ; while [edi] != al
    49                                  
    50 000000BF 29DF                        sub     edi, ebx     
    51 000000C1 89F8                        mov     eax, edi     
    52                                  
    53 000000C3 C3                          ret         
    54                                  ; end of strlen 
    55                                  
    56                                  ;------------------------------------------------
    57                                  ; PRINTF
    58                                  ; 
    59                                  ; CHANGED: esi, eax, dl, ecx (ret), ebx
    60                                  ;------------------------------------------------
    61                                  printf:
    62                                      ; si is where we read string
    63 000000C4 59                          pop     ecx
    64 000000C5 890D[30000000]              mov     [ret_addr], ecx
    65 000000CB 5E                          pop     esi
    66 000000CC 89F7                        mov     edi, esi
    67 000000CE 4E                          dec     esi      ; useful because you do not need to inc it befoure calling loop
    68                                  
    69                                      .printf_loop:
    70 000000CF 46                              inc     esi
    71 000000D0 8A06                            mov     al, [esi]
    72 000000D2 3C25                            cmp     al, '%'
    73 000000D4 742D                            je      .codes
    74                                  
    75 000000D6 3C00                            cmp     al, 0
    76 000000D8 7417                            je      .ret
    77                                  
    78                                          WRITE   esi, 1
     9                              <1> 
    10 000000DA 6A00                <1>  push dword 0
    11 000000DC 68[00000000]        <1>  push numCharsWritten
    12 000000E1 6A01                <1>  push dword %2
    13 000000E3 56                  <1>  push dword %1
    14 000000E4 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000000EA E8(00000000)        <1>  call WriteConsoleA
    79                                          
    80 000000EF EBDE                            jmp     .printf_loop
    81                                  
    82                                  .ret:
    83 000000F1 8B0D[30000000]              mov     ecx, [ret_addr]
    84 000000F7 51                          push    ecx
    85 000000F8 C3                          ret
    86                                  
    87                                  .jmp_percent:
    88 000000F9 E98D010000                  jmp     .percent
    89                                  
    90                                  .jmp_default:
    91 000000FE E9AD010000                  jmp     .default
    92                                  
    93                                  .codes:
    94 00000103 46                          inc     esi
    95 00000104 8A06                        mov     al, [esi]
    96                                  
    97 00000106 3C25                        cmp     al, '%'
    98 00000108 74EF                        je      .jmp_percent
    99 0000010A 3C62                        cmp     al, 'b'
   100 0000010C 7CF0                        jl      .jmp_default    ; less than 'b'
   101 0000010E 3C78                        cmp     al, 'x'
   102 00000110 7FEC                        jg      .jmp_default    ; more than 'x'
   103                                  
   104 00000112 2C62                        sub     al, 'b'
   105 00000114 31DB                        xor     ebx, ebx
   106 00000116 88C3                        mov     bl, al
   107                                      ; ebx = 4*al
   108 00000118 01DB                        add     ebx, ebx
   109 0000011A 01DB                        add     ebx, ebx
   110                                  
   111 0000011C 8B9B[24010000]              mov     ebx, [ebx + .jmp_table]
   112 00000122 FFE3                        jmp     ebx
   113                                  
   114                                  .jmp_table:
   115                                      ; hardcoded jmp table
   116 00000124 [AF010000]                  dd      .bin 
   117 00000128 [42020000]                  dd      .char
   118 0000012C [80010000]                  dd      .dec
   119 00000130 [B0020000]-                 dd      10 dup(.default)
   119 00000134 [B0020000]-        
   119 00000138 [B0020000]-        
   119 0000013C [B0020000]-        
   119 00000140 [B0020000]-        
   119 00000144 [B0020000]-        
   119 00000148 [B0020000]-        
   119 0000014C [B0020000]-        
   119 00000150 [B0020000]-        
   119 00000154 [B0020000]         
   120 00000158 [E0010000]                  dd      .oct
   121 0000015C [B0020000]-                 dd      3 dup(.default)
   121 00000160 [B0020000]-        
   121 00000164 [B0020000]         
   122 00000168 [66020000]                  dd      .str
   123 0000016C [B0020000]-                 dd      4 dup(.default)
   123 00000170 [B0020000]-        
   123 00000174 [B0020000]-        
   123 00000178 [B0020000]         
   124 0000017C [11020000]                  dd      .hex
   125                                  
   126                                  .dec:
   127 00000180 58                          pop     eax
   128 00000181 56                          push    esi
   129                                  
   130 00000182 BF[08000000]                mov     edi, itoaBuff
   131 00000187 B90A000000                  mov     ecx, 10
   132 0000018C E86FFEFFFF                  call    itoa
   133                                  
   134 00000191 5E                          pop     esi
   135                                  
   136                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000192 6A00                <1>  push dword 0
    11 00000194 68[00000000]        <1>  push numCharsWritten
    12 00000199 50                  <1>  push dword %2
    13 0000019A 68[08000000]        <1>  push dword %1
    14 0000019F FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001A5 E8(00000000)        <1>  call WriteConsoleA
   137 000001AA E920FFFFFF                  jmp     .printf_loop
   138                                  
   139                                  .bin:
   140 000001AF 58                          pop     eax
   141 000001B0 56                          push    esi
   142                                  
   143 000001B1 BF[08000000]                mov     edi, itoaBuff
   144 000001B6 B901000000                  mov     ecx, 1
   145 000001BB 30FF                        xor     bh, bh
   146 000001BD E88AFEFFFF                  call    itoa2n
   147                                  
   148 000001C2 5E                          pop     esi
   149                                  
   150                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001C3 6A00                <1>  push dword 0
    11 000001C5 68[00000000]        <1>  push numCharsWritten
    12 000001CA 50                  <1>  push dword %2
    13 000001CB 68[08000000]        <1>  push dword %1
    14 000001D0 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001D6 E8(00000000)        <1>  call WriteConsoleA
   151 000001DB E9EFFEFFFF                  jmp     .printf_loop
   152                                  
   153                                  .oct:
   154 000001E0 58                          pop     eax
   155 000001E1 56                          push    esi
   156                                  
   157 000001E2 BF[08000000]                mov     edi, itoaBuff
   158 000001E7 B903000000                  mov     ecx, 3
   159 000001EC 30FF                        xor     bh, bh
   160 000001EE E859FEFFFF                  call    itoa2n
   161                                  
   162 000001F3 5E                          pop     esi
   163                                  
   164                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001F4 6A00                <1>  push dword 0
    11 000001F6 68[00000000]        <1>  push numCharsWritten
    12 000001FB 50                  <1>  push dword %2
    13 000001FC 68[08000000]        <1>  push dword %1
    14 00000201 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000207 E8(00000000)        <1>  call WriteConsoleA
   165 0000020C E9BEFEFFFF                  jmp     .printf_loop
   166                                  
   167                                  .hex:
   168 00000211 58                          pop     eax
   169 00000212 56                          push    esi
   170                                  
   171 00000213 BF[08000000]                mov     edi, itoaBuff
   172 00000218 B904000000                  mov     ecx, 4
   173 0000021D 30FF                        xor     bh, bh
   174 0000021F E828FEFFFF                  call    itoa2n
   175                                  
   176 00000224 5E                          pop     esi
   177                                  
   178                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000225 6A00                <1>  push dword 0
    11 00000227 68[00000000]        <1>  push numCharsWritten
    12 0000022C 50                  <1>  push dword %2
    13 0000022D 68[08000000]        <1>  push dword %1
    14 00000232 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000238 E8(00000000)        <1>  call WriteConsoleA
   179 0000023D E98DFEFFFF                  jmp     .printf_loop
   180                                  
   181                                  .char:
   182 00000242 58                          pop     eax
   183 00000243 A2[08000000]                mov     [itoaBuff], al
   184                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 00000248 6A00                <1>  push dword 0
    11 0000024A 68[00000000]        <1>  push numCharsWritten
    12 0000024F 6A01                <1>  push dword %2
    13 00000251 68[08000000]        <1>  push dword %1
    14 00000256 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 0000025C E8(00000000)        <1>  call WriteConsoleA
   185 00000261 E969FEFFFF                  jmp     .printf_loop
   186                                  
   187                                  .str:
   188 00000266 58                          pop     eax
   189 00000267 56                          push    esi
   190                                  
   191 00000268 89C6                        mov     esi, eax
   192 0000026A 89C7                        mov     edi, eax
   193 0000026C E843FEFFFF                  call    strlen
   194                                  
   195                                      WRITE   esi, eax
     9                              <1> 
    10 00000271 6A00                <1>  push dword 0
    11 00000273 68[00000000]        <1>  push numCharsWritten
    12 00000278 50                  <1>  push dword %2
    13 00000279 56                  <1>  push dword %1
    14 0000027A FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000280 E8(00000000)        <1>  call WriteConsoleA
   196                                  
   197 00000285 5E                          pop     esi
   198                                  
   199 00000286 E944FEFFFF                  jmp     .printf_loop
   200                                  
   201                                  .percent:
   202 0000028B C605[08000000]25            mov     byte [itoaBuff], '%'
   203                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 00000292 6A00                <1>  push dword 0
    11 00000294 68[00000000]        <1>  push numCharsWritten
    12 00000299 6A01                <1>  push dword %2
    13 0000029B 68[08000000]        <1>  push dword %1
    14 000002A0 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002A6 E8(00000000)        <1>  call WriteConsoleA
   204 000002AB E91FFEFFFF                  jmp     .printf_loop
   205                                  
   206                                  .default:
   207 000002B0 E91AFEFFFF                  jmp     .printf_loop
   208                                  
   209                                  ; end of printf
   210                                  
   211                                  _start:
   212                                  
   213                                      ; GetStdHandle( STD_OUTPUT_HANDLE )
   214 000002B5 6AF5                        push    dword -11
   215 000002B7 E8(00000000)                call    GetStdHandle ; returns in eax
   216 000002BC A3[04000000]                mov     [STDOutputHandle], eax
   217                                  
   218 000002C1 6A11                        push    dword 17
   219 000002C3 68DE000000                  push    dword 0DEh
   220 000002C8 68[2E030000]                push    dword  str_wr
   221 000002CD 6A6A                        push    dword 'j'
   222 000002CF 6A06                        push    dword 6
   223 000002D1 6841050000                  push    dword 1345
   224 000002D6 68[E7020000]                push    dword  str_to_printf
   225 000002DB E8E4FDFFFF                  call    printf
   226                                  
   227                                      ; ExitProcess( 0 )
   228 000002E0 6A00                        push    dword 0   
   229 000002E2 E8(00000000)                call    ExitProcess
   230                                  
   231 000002E7 5052494E5446464646-         str_to_printf db "PRINTFFFF %d was not %b and %c so it is %s and %x but not %o (not 0)", 10, "a", 0
   231 000002F0 20256420776173206E-
   231 000002F9 6F7420256220616E64-
   231 00000302 20256320736F206974-
   231 0000030B 20697320257320616E-
   231 00000314 642025782062757420-
   231 0000031D 6E6F7420256F20286E-
   231 00000326 6F742030290A6100   
   232 0000032E 736F6D652073747200          str_wr        db "some str", 0
   233                                  
   234 00000337 4445420A00                  DEBSTR db "DEB", 10, 0
