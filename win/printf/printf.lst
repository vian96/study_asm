     1                                  global printf
     2                                  
     3                                  extern GetStdHandle
     4                                  extern WriteConsoleA
     5                                  extern ExitProcess
     6                                  
     7                                  ; First arg is str and second is length
     8                                  %macro WRITE 2
     9                                  ; WriteConsole( STD_OUTPUT_HANDLE, strbuffer, numofchar, numwritten, double 0)
    10                                          push    dword 0         
    11                                          push    numCharsWritten
    12                                          push    dword %2    
    13                                          push    dword %1             
    14                                          push    dword    [STDOutputHandle]
    15                                          call    WriteConsoleA
    16                                  %endmacro ; WRITE
    17                                  
    18                                  %define DEB     WRITE DEBSTR, 4
    19                                  
    20                                  section .data
    21 00000000 78656C6C6F2C20776F-             str:     db 'xello, world!', 0x0D, 0x0A, 0 ; \r\n\0
    21 00000009 726C64210D0A00     
    22                                          strLen:  equ $-str
    23                                  
    24                                  section .bss
    25 00000000 ????????                        numCharsWritten     resd 1
    26 00000004 ????????                        STDOutputHandle     resd 1
    27                                  
    28 00000008 <res 28h>                       itoaBuff            resb 40 ; because 32 + some buffer space
    29 00000030 ????????                        ret_addr            resd 1
    30                                  
    31                                  
    32                                  section .text
    33                                  
    34                                  %include "itoa.asm"
    35                              <1> ;------------------------------------------------
    36                              <1> ; ITOA
    37                              <1> ; Translates unsigned bx number to str pointed by di with base cx and places $ at the end
    38                              <1> ;   edi - ptr of str to be written
    39                              <1> ;   ecx - base
    40                              <1> ;   eax - number to be translated
    41                              <1> ; CHANGED: ebx, edx, edi, esi
    42                              <1> ; RETURNED: eax - length
    43                              <1> ;------------------------------------------------
    44                              <1> itoa:
    45 00000000 39C8                <1>     cmp eax, ecx
    46 00000002 7F12                <1>     jg .main_itoa
    47                              <1> 
    48 00000004 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
    49 0000000A 8817                <1>     mov [edi], dl
    50 0000000C C6470100            <1>     mov byte [edi+1], 0
    51 00000010 B801000000          <1>     mov eax, 1
    52 00000015 C3                  <1>     ret
    53                              <1> 
    54                              <1> .main_itoa:
    55 00000016 89FE                <1>     mov esi, edi
    56                              <1> 
    57                              <1>     .loop:
    58 00000018 BA00000000          <1>         mov edx, 0
    59 0000001D F7F1                <1>         div ecx              ; eax = edx:eax div ecx, edx = edx:eax % ecx
    60 0000001F 89D3                <1>         mov ebx, edx
    61 00000021 8A93[A4000000]      <1>         mov dl, [ebx + XlatTable]
    62                              <1> 
    63 00000027 8817                <1>         mov [edi], dl
    64 00000029 47                  <1>         inc edi
    65                              <1> 
    66 0000002A 83F800              <1>         cmp eax, 0
    67 0000002D 7402                <1>         je .end_loop
    68 0000002F EBE7                <1>     jmp .loop
    69                              <1> 
    70                              <1> .end_loop:
    71 00000031 89F9                <1>     mov ecx, edi
    72 00000033 29F1                <1>     sub ecx, esi
    73 00000035 D1E9                <1>     shr ecx, 1
    74 00000037 C60700              <1>     mov byte [edi], 0
    75 0000003A 89FA                <1>     mov edx, edi
    76 0000003C 29F2                <1>     sub edx, esi
    77 0000003E 4F                  <1>     dec edi
    78                              <1> 
    79                              <1>     .reverse_ans:
    80 0000003F 8A07                <1>         mov al, [edi]
    81 00000041 8606                <1>         xchg [esi], al
    82 00000043 8807                <1>         mov [edi], al
    83                              <1> 
    84 00000045 4F                  <1>         dec edi
    85 00000046 46                  <1>         inc esi
    86 00000047 E2F6                <1>     loop .reverse_ans
    87                              <1> 
    88 00000049 89D0                <1>     mov eax, edx ; returned value is length
    89 0000004B C3                  <1>     ret
    90                              <1> 
    91                              <1> ; end of itoa
    92                              <1> 
    93                              <1> 
    94                              <1> ;------------------------------------------------
    95                              <1> ; ITOA2N
    96                              <1> ; Translates unsigned bx number to str pointed by di with base 2^cl and places $ at the end
    97                              <1> ;   di - ptr of str to be written
    98                              <1> ;   cl - power of base
    99                              <1> ;   ax - number to be translated
   100                              <1> ;   bh = 0
   101                              <1> ; CHANGED: bx, dx, di, si
   102                              <1> ;------------------------------------------------
   103                              <1> itoa2n:
   104 0000004C BB01000000          <1>     mov ebx, 1
   105 00000051 D3E3                <1>     shl ebx, cl
   106 00000053 39D8                <1>     cmp eax, ebx
   107 00000055 7F12                <1>     jg .main_itoa2n
   108                              <1> 
   109 00000057 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
   110 0000005D 8817                <1>     mov [edi], dl
   111 0000005F C6470100            <1>     mov byte [edi+1], 0
   112 00000063 B801000000          <1>     mov eax, 1
   113 00000068 C3                  <1>     ret
   114                              <1> 
   115                              <1> .main_itoa2n:
   116 00000069 89FE                <1>     mov esi, edi
   117 0000006B BA01000000          <1>     mov edx, 1
   118 00000070 D3E2                <1>     shl edx, cl
   119 00000072 4A                  <1>     dec edx                  ; dx = 2^cl - 1
   120                              <1> 
   121                              <1>     .loop:
   122 00000073 89C3                <1>         mov ebx, eax
   123 00000075 21D3                <1>         and ebx, edx          ; bx = ax % 2^cl
   124 00000077 D3E8                <1>         shr eax, cl          ; ax = ax / 2^cl
   125                              <1> 
   126 00000079 8A9B[A4000000]      <1>         mov bl, [ebx + XlatTable]
   127 0000007F 881F                <1>         mov [edi], bl
   128 00000081 47                  <1>         inc edi
   129                              <1> 
   130 00000082 83F800              <1>         cmp eax, 0
   131 00000085 7402                <1>         je .end_loop
   132 00000087 EBEA                <1>     jmp .loop
   133                              <1> 
   134                              <1>     ; TODO is it okay to have copypaste like this?
   135                              <1>     .end_loop:
   136 00000089 89F9                <1>     mov ecx, edi
   137 0000008B 29F1                <1>     sub ecx, esi
   138 0000008D D1E9                <1>     shr ecx, 1
   139 0000008F C60700              <1>     mov byte [edi], 0
   140 00000092 89FA                <1>     mov edx, edi
   141 00000094 29F2                <1>     sub edx, esi
   142 00000096 4F                  <1>     dec edi
   143                              <1> 
   144                              <1>     .reverse:
   145 00000097 8A07                <1>         mov al, [edi]
   146 00000099 8606                <1>         xchg [esi], al
   147 0000009B 8807                <1>         mov [edi], al
   148                              <1> 
   149 0000009D 4F                  <1>         dec edi
   150 0000009E 46                  <1>         inc esi
   151 0000009F E2F6                <1>     loop .reverse
   152                              <1> 
   153 000000A1 89D0                <1>     mov eax, edx ; returned value is length
   154 000000A3 C3                  <1>     ret
   155                              <1> 
   156                              <1> ; end of itoa2n
   157                              <1> 
   158 000000A4 303132333435363738- <1>     XlatTable db '0123456789ABCDEF'
   158 000000AD 39414243444546      <1>
    35                                  
    36                                  ;------------------------------------------------
    37                                  ; STRLEN
    38                                  ; edi - source of str
    39                                  ; CHANGED: ecx, edi, eax, ebx
    40                                  ; RETURN: eax - len
    41                                  ;------------------------------------------------
    42                                  strlen:
    43                                      ; TODO check flags of direction
    44 000000B4 89FB                        mov     ebx, edi
    45 000000B6 30C0                        xor     al, al  
    46 000000B8 B9FFFFFFFF                  mov     ecx, 0xffffffff
    47                                  
    48 000000BD F2AE                        repne   scasb   ; while [edi] != al
    49                                  
    50 000000BF 29DF                        sub     edi, ebx     
    51 000000C1 89F8                        mov     eax, edi     
    52 000000C3 48                          dec eax
    53                                  
    54 000000C4 C3                          ret         
    55                                  ; end of strlen 
    56                                  
    57                                  ;------------------------------------------------
    58                                  ; MACRO FOR PRINTF
    59                                  ; Writes ecx symbols from esi and see code, its simple
    60                                  ;------------------------------------------------
    61                                  %macro WRITE_BUF 0
    62                                      WRITE edi, ecx
    63                                      xor ecx, ecx
    64                                      mov edi, esi
    65                                      add edi, 2      ; to move from % to actual string
    66                                  %endmacro ; WRITE_BUF
    67                                  
    68                                  ;------------------------------------------------
    69                                  ; PRINTF
    70                                  ; 
    71                                  ; CHANGED: esi, eax, dl, ecx (ret), ebx
    72                                  ;------------------------------------------------
    73                                  printf:
    74                                      ; si is where we read string
    75 000000C5 59                          pop     ecx
    76 000000C6 890D[30000000]              mov     [ret_addr], ecx
    77 000000CC 5E                          pop     esi
    78 000000CD 89F7                        mov     edi, esi
    79 000000CF 4E                          dec     esi      ; useful because you do not need to inc it befoure calling loop
    80 000000D0 31C9                        xor ecx, ecx
    81                                  
    82                                      .printf_loop:
    83 000000D2 46                              inc     esi
    84 000000D3 8A06                            mov     al, [esi]
    85 000000D5 3C25                            cmp     al, '%'
    86 000000D7 7434                            je      .codes
    87                                  
    88 000000D9 3C00                            cmp     al, 0
    89 000000DB 7403                            je      .ret
    90                                  
    91 000000DD 41                              inc ecx
    92 000000DE EBF2                            jmp     .printf_loop
    93                                  
    94                                  .ret:
    95                                      WRITE_BUF
    62                              <1>  WRITE edi, ecx
     9                              <2> 
    10 000000E0 6A00                <2>  push dword 0
    11 000000E2 68[00000000]        <2>  push numCharsWritten
    12 000000E7 51                  <2>  push dword %2
    13 000000E8 57                  <2>  push dword %1
    14 000000E9 FF35[04000000]      <2>  push dword [STDOutputHandle]
    15 000000EF E8(00000000)        <2>  call WriteConsoleA
    63 000000F4 31C9                <1>  xor ecx, ecx
    64 000000F6 89F7                <1>  mov edi, esi
    65 000000F8 83C702              <1>  add edi, 2
    96 000000FB 8B0D[30000000]              mov     ecx, [ret_addr]
    97 00000101 51                          push    ecx
    98 00000102 C3                          ret
    99                                  
   100                                  .jmp_percent:
   101 00000103 E9BE010000                  jmp     .percent
   102                                  
   103                                  .jmp_default:
   104 00000108 E9DE010000                  jmp     .default
   105                                  
   106                                  .codes:
   107                                      WRITE_BUF
    62                              <1>  WRITE edi, ecx
     9                              <2> 
    10 0000010D 6A00                <2>  push dword 0
    11 0000010F 68[00000000]        <2>  push numCharsWritten
    12 00000114 51                  <2>  push dword %2
    13 00000115 57                  <2>  push dword %1
    14 00000116 FF35[04000000]      <2>  push dword [STDOutputHandle]
    15 0000011C E8(00000000)        <2>  call WriteConsoleA
    63 00000121 31C9                <1>  xor ecx, ecx
    64 00000123 89F7                <1>  mov edi, esi
    65 00000125 83C702              <1>  add edi, 2
   108                                  
   109 00000128 46                          inc     esi
   110 00000129 8A06                        mov     al, [esi]
   111                                  
   112 0000012B 3C25                        cmp     al, '%'
   113 0000012D 74D4                        je      .jmp_percent
   114 0000012F 3C62                        cmp     al, 'b'
   115 00000131 7CD5                        jl      .jmp_default    ; less than 'b'
   116 00000133 3C78                        cmp     al, 'x'
   117 00000135 7FD1                        jg      .jmp_default    ; more than 'x'
   118                                  
   119 00000137 2C62                        sub     al, 'b'
   120 00000139 31DB                        xor     ebx, ebx
   121 0000013B 88C3                        mov     bl, al
   122                                      ; ebx = 4*al
   123 0000013D 01DB                        add     ebx, ebx
   124 0000013F 01DB                        add     ebx, ebx
   125                                  
   126 00000141 8B9B[49010000]              mov     ebx, [ebx + .jmp_table]
   127 00000147 FFE3                        jmp     ebx
   128                                  
   129                                  .jmp_table:
   130                                      ; hardcoded jmp table
   131 00000149 [D8010000]                  dd      .bin 
   132 0000014D [77020000]                  dd      .char
   133 00000151 [A5010000]                  dd      .dec
   134 00000155 [EB020000]-                 dd      10 dup(.default)
   134 00000159 [EB020000]-        
   134 0000015D [EB020000]-        
   134 00000161 [EB020000]-        
   134 00000165 [EB020000]-        
   134 00000169 [EB020000]-        
   134 0000016D [EB020000]-        
   134 00000171 [EB020000]-        
   134 00000175 [EB020000]-        
   134 00000179 [EB020000]         
   135 0000017D [0D020000]                  dd      .oct
   136 00000181 [EB020000]-                 dd      3 dup(.default)
   136 00000185 [EB020000]-        
   136 00000189 [EB020000]         
   137 0000018D [9D020000]                  dd      .str
   138 00000191 [EB020000]-                 dd      4 dup(.default)
   138 00000195 [EB020000]-        
   138 00000199 [EB020000]-        
   138 0000019D [EB020000]         
   139 000001A1 [42020000]                  dd      .hex
   140                                  
   141                                  .dec:
   142 000001A5 58                          pop     eax
   143 000001A6 56                          push    esi
   144 000001A7 57                          push    edi
   145 000001A8 51                          push    ecx
   146                                  
   147 000001A9 BF[08000000]                mov     edi, itoaBuff
   148 000001AE B90A000000                  mov     ecx, 10
   149 000001B3 E848FEFFFF                  call    itoa
   150                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001B8 6A00                <1>  push dword 0
    11 000001BA 68[00000000]        <1>  push numCharsWritten
    12 000001BF 50                  <1>  push dword %2
    13 000001C0 68[08000000]        <1>  push dword %1
    14 000001C5 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001CB E8(00000000)        <1>  call WriteConsoleA
   151                                  
   152 000001D0 59                          pop     ecx
   153 000001D1 5F                          pop     edi
   154 000001D2 5E                          pop     esi
   155 000001D3 E9FAFEFFFF                  jmp     .printf_loop
   156                                  
   157                                  .bin:
   158 000001D8 58                          pop     eax
   159 000001D9 56                          push    esi
   160 000001DA 57                          push    edi
   161 000001DB 51                          push    ecx
   162                                  
   163 000001DC BF[08000000]                mov     edi, itoaBuff
   164 000001E1 B901000000                  mov     ecx, 1
   165 000001E6 30FF                        xor     bh, bh
   166 000001E8 E85FFEFFFF                  call    itoa2n
   167                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001ED 6A00                <1>  push dword 0
    11 000001EF 68[00000000]        <1>  push numCharsWritten
    12 000001F4 50                  <1>  push dword %2
    13 000001F5 68[08000000]        <1>  push dword %1
    14 000001FA FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000200 E8(00000000)        <1>  call WriteConsoleA
   168                                  
   169 00000205 59                          pop     ecx
   170 00000206 5F                          pop     edi
   171 00000207 5E                          pop     esi
   172 00000208 E9C5FEFFFF                  jmp     .printf_loop
   173                                  
   174                                  .oct:
   175 0000020D 58                          pop     eax
   176 0000020E 56                          push    esi
   177 0000020F 57                          push    edi
   178 00000210 51                          push    ecx
   179                                  
   180 00000211 BF[08000000]                mov     edi, itoaBuff
   181 00000216 B903000000                  mov     ecx, 3
   182 0000021B 30FF                        xor     bh, bh
   183 0000021D E82AFEFFFF                  call    itoa2n
   184                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000222 6A00                <1>  push dword 0
    11 00000224 68[00000000]        <1>  push numCharsWritten
    12 00000229 50                  <1>  push dword %2
    13 0000022A 68[08000000]        <1>  push dword %1
    14 0000022F FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000235 E8(00000000)        <1>  call WriteConsoleA
   185                                  
   186 0000023A 59                          pop     ecx
   187 0000023B 5F                          pop     edi
   188 0000023C 5E                          pop     esi
   189 0000023D E990FEFFFF                  jmp     .printf_loop
   190                                  
   191                                  .hex:
   192 00000242 58                          pop     eax
   193 00000243 56                          push    esi
   194 00000244 57                          push    edi
   195 00000245 51                          push    ecx
   196                                  
   197 00000246 BF[08000000]                mov     edi, itoaBuff
   198 0000024B B904000000                  mov     ecx, 4
   199 00000250 30FF                        xor     bh, bh
   200 00000252 E8F5FDFFFF                  call    itoa2n
   201                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000257 6A00                <1>  push dword 0
    11 00000259 68[00000000]        <1>  push numCharsWritten
    12 0000025E 50                  <1>  push dword %2
    13 0000025F 68[08000000]        <1>  push dword %1
    14 00000264 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 0000026A E8(00000000)        <1>  call WriteConsoleA
   202                                  
   203 0000026F 59                          pop     ecx
   204 00000270 5F                          pop     edi
   205 00000271 5E                          pop     esi
   206 00000272 E95BFEFFFF                  jmp     .printf_loop
   207                                  
   208                                  .char:
   209 00000277 58                          pop     eax
   210 00000278 A2[08000000]                mov     [itoaBuff], al
   211 0000027D 51                          push    ecx
   212                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 0000027E 6A00                <1>  push dword 0
    11 00000280 68[00000000]        <1>  push numCharsWritten
    12 00000285 6A01                <1>  push dword %2
    13 00000287 68[08000000]        <1>  push dword %1
    14 0000028C FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000292 E8(00000000)        <1>  call WriteConsoleA
   213 00000297 59                          pop     ecx
   214 00000298 E935FEFFFF                  jmp     .printf_loop
   215                                  
   216                                  .str:
   217 0000029D 58                          pop     eax
   218 0000029E 56                          push    esi
   219 0000029F 57                          push    edi
   220 000002A0 51                          push    ecx
   221                                  
   222 000002A1 89C6                        mov     esi, eax
   223 000002A3 89C7                        mov     edi, eax
   224 000002A5 E80AFEFFFF                  call    strlen
   225                                  
   226                                      WRITE   esi, eax
     9                              <1> 
    10 000002AA 6A00                <1>  push dword 0
    11 000002AC 68[00000000]        <1>  push numCharsWritten
    12 000002B1 50                  <1>  push dword %2
    13 000002B2 56                  <1>  push dword %1
    14 000002B3 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002B9 E8(00000000)        <1>  call WriteConsoleA
   227                                  
   228 000002BE 59                          pop     ecx
   229 000002BF 5F                          pop     edi
   230 000002C0 5E                          pop     esi
   231                                  
   232 000002C1 E90CFEFFFF                  jmp     .printf_loop
   233                                  
   234                                  .percent:
   235 000002C6 C605[08000000]25            mov     byte [itoaBuff], '%'
   236                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 000002CD 6A00                <1>  push dword 0
    11 000002CF 68[00000000]        <1>  push numCharsWritten
    12 000002D4 6A01                <1>  push dword %2
    13 000002D6 68[08000000]        <1>  push dword %1
    14 000002DB FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002E1 E8(00000000)        <1>  call WriteConsoleA
   237 000002E6 E9E7FDFFFF                  jmp     .printf_loop
   238                                  
   239                                  .default:
   240 000002EB E9E2FDFFFF                  jmp     .printf_loop
   241                                  
   242                                  ; end of printf
   243                                  
   244 000002F0 5052494E5446464646-         str_to_printf db "PRINTFFFF %d was not %b and %c so it is %s and %x but not %o (not 0)", 10, "a", 0
   244 000002F9 20256420776173206E-
   244 00000302 6F7420256220616E64-
   244 0000030B 20256320736F206974-
   244 00000314 20697320257320616E-
   244 0000031D 642025782062757420-
   244 00000326 6E6F7420256F20286E-
   244 0000032F 6F742030290A6100   
   245 00000337 736F6D652073747200          str_wr        db "some str", 0
   246                                  
   247 00000340 4445420A00                  DEBSTR db "DEB", 10, 0
