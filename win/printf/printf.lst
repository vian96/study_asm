     1                                  global _start
     2                                  
     3                                  extern GetStdHandle
     4                                  extern WriteConsoleA
     5                                  extern ExitProcess
     6                                  
     7                                  ; First arg is str and second is length
     8                                  %macro WRITE 2
     9                                  ; WriteConsole( STD_OUTPUT_HANDLE, strbuffer, numofchar, numwritten, double 0)
    10                                          push    dword 0         
    11                                          push    numCharsWritten
    12                                          push    dword %2    
    13                                          push    dword %1             
    14                                          push    dword    [STDOutputHandle]
    15                                          call    WriteConsoleA
    16                                  %endmacro ; WRITE
    17                                  
    18                                  %define DEB     WRITE DEBSTR, 4
    19                                  
    20                                  section .data
    21 00000000 78656C6C6F2C20776F-             str:     db 'xello, world!', 0x0D, 0x0A, 0 ; \r\n\0
    21 00000009 726C64210D0A00     
    22                                          strLen:  equ $-str
    23                                  
    24                                  section .bss
    25 00000000 ????????                        numCharsWritten     resd 1
    26 00000004 ????????                        STDOutputHandle     resd 1
    27                                  
    28 00000008 <res 28h>                       itoaBuff            resb 40 ; because 32 + some buffer space
    29 00000030 ????????                        ret_addr            resd 1
    30                                  
    31                                  
    32                                  section .text
    33                                  
    34                                  %include "itoa.asm"
    35                              <1> ;------------------------------------------------
    36                              <1> ; ITOA
    37                              <1> ; Translates unsigned bx number to str pointed by di with base cx and places $ at the end
    38                              <1> ;   edi - ptr of str to be written
    39                              <1> ;   ecx - base
    40                              <1> ;   eax - number to be translated
    41                              <1> ; CHANGED: ebx, edx, edi, esi
    42                              <1> ; RETURNED: eax - length
    43                              <1> ;------------------------------------------------
    44                              <1> itoa:
    45 00000000 39C8                <1>     cmp eax, ecx
    46 00000002 7F12                <1>     jg .main_itoa
    47                              <1> 
    48 00000004 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
    49 0000000A 8817                <1>     mov [edi], dl
    50 0000000C C6470100            <1>     mov byte [edi+1], 0
    51 00000010 B801000000          <1>     mov eax, 1
    52 00000015 C3                  <1>     ret
    53                              <1> 
    54                              <1> .main_itoa:
    55 00000016 89FE                <1>     mov esi, edi
    56                              <1> 
    57                              <1>     .loop:
    58 00000018 BA00000000          <1>         mov edx, 0
    59 0000001D F7F1                <1>         div ecx              ; eax = edx:eax div ecx, edx = edx:eax % ecx
    60 0000001F 89D3                <1>         mov ebx, edx
    61 00000021 8A93[A4000000]      <1>         mov dl, [ebx + XlatTable]
    62                              <1> 
    63 00000027 8817                <1>         mov [edi], dl
    64 00000029 47                  <1>         inc edi
    65                              <1> 
    66 0000002A 83F800              <1>         cmp eax, 0
    67 0000002D 7402                <1>         je .end_loop
    68 0000002F EBE7                <1>     jmp .loop
    69                              <1> 
    70                              <1> .end_loop:
    71 00000031 89F9                <1>     mov ecx, edi
    72 00000033 29F1                <1>     sub ecx, esi
    73 00000035 D1E9                <1>     shr ecx, 1
    74 00000037 C60700              <1>     mov byte [edi], 0
    75 0000003A 89FA                <1>     mov edx, edi
    76 0000003C 29F2                <1>     sub edx, esi
    77 0000003E 4F                  <1>     dec edi
    78                              <1> 
    79                              <1>     .reverse_ans:
    80 0000003F 8A07                <1>         mov al, [edi]
    81 00000041 8606                <1>         xchg [esi], al
    82 00000043 8807                <1>         mov [edi], al
    83                              <1> 
    84 00000045 4F                  <1>         dec edi
    85 00000046 46                  <1>         inc esi
    86 00000047 E2F6                <1>     loop .reverse_ans
    87                              <1> 
    88 00000049 89D0                <1>     mov eax, edx ; returned value is length
    89 0000004B C3                  <1>     ret
    90                              <1> 
    91                              <1> ; end of itoa
    92                              <1> 
    93                              <1> 
    94                              <1> ;------------------------------------------------
    95                              <1> ; ITOA2N
    96                              <1> ; Translates unsigned bx number to str pointed by di with base 2^cl and places $ at the end
    97                              <1> ;   di - ptr of str to be written
    98                              <1> ;   cl - power of base
    99                              <1> ;   ax - number to be translated
   100                              <1> ;   bh = 0
   101                              <1> ; CHANGED: bx, dx, di, si
   102                              <1> ;------------------------------------------------
   103                              <1> itoa2n:
   104 0000004C BB01000000          <1>     mov ebx, 1
   105 00000051 D3E3                <1>     shl ebx, cl
   106 00000053 39D8                <1>     cmp eax, ebx
   107 00000055 7F12                <1>     jg .main_itoa2n
   108                              <1> 
   109 00000057 8A90[A4000000]      <1>     mov dl, [eax + XlatTable]
   110 0000005D 8817                <1>     mov [edi], dl
   111 0000005F C6470100            <1>     mov byte [edi+1], 0
   112 00000063 B801000000          <1>     mov eax, 1
   113 00000068 C3                  <1>     ret
   114                              <1> 
   115                              <1> .main_itoa2n:
   116 00000069 89FE                <1>     mov esi, edi
   117 0000006B BA01000000          <1>     mov edx, 1
   118 00000070 D3E2                <1>     shl edx, cl
   119 00000072 4A                  <1>     dec edx                  ; dx = 2^cl - 1
   120                              <1> 
   121                              <1>     .loop:
   122 00000073 89C3                <1>         mov ebx, eax
   123 00000075 21D3                <1>         and ebx, edx          ; bx = ax % 2^cl
   124 00000077 D3E8                <1>         shr eax, cl          ; ax = ax / 2^cl
   125                              <1> 
   126 00000079 8A9B[A4000000]      <1>         mov bl, [ebx + XlatTable]
   127 0000007F 881F                <1>         mov [edi], bl
   128 00000081 47                  <1>         inc edi
   129                              <1> 
   130 00000082 83F800              <1>         cmp eax, 0
   131 00000085 7402                <1>         je .end_loop
   132 00000087 EBEA                <1>     jmp .loop
   133                              <1> 
   134                              <1>     ; TODO is it okay to have copypaste like this?
   135                              <1>     .end_loop:
   136 00000089 89F9                <1>     mov ecx, edi
   137 0000008B 29F1                <1>     sub ecx, esi
   138 0000008D D1E9                <1>     shr ecx, 1
   139 0000008F C60700              <1>     mov byte [edi], 0
   140 00000092 89FA                <1>     mov edx, edi
   141 00000094 29F2                <1>     sub edx, esi
   142 00000096 4F                  <1>     dec edi
   143                              <1> 
   144                              <1>     .reverse:
   145 00000097 8A07                <1>         mov al, [edi]
   146 00000099 8606                <1>         xchg [esi], al
   147 0000009B 8807                <1>         mov [edi], al
   148                              <1> 
   149 0000009D 4F                  <1>         dec edi
   150 0000009E 46                  <1>         inc esi
   151 0000009F E2F6                <1>     loop .reverse
   152                              <1> 
   153 000000A1 89D0                <1>     mov eax, edx ; returned value is length
   154 000000A3 C3                  <1>     ret
   155                              <1> 
   156                              <1> ; end of itoa2n
   157                              <1> 
   158 000000A4 303132333435363738- <1>     XlatTable db '0123456789ABCDEF'
   158 000000AD 39414243444546      <1>
    35                                  
    36                                  ;------------------------------------------------
    37                                  ; STRLEN
    38                                  ; edi - source of str
    39                                  ; CHANGED: ecx, edi, eax, ebx
    40                                  ; RETURN: eax - len
    41                                  ;------------------------------------------------
    42                                  strlen:
    43                                      ; TODO check flags of direction
    44 000000B4 89FB                        mov     ebx, edi
    45 000000B6 30C0                        xor     al, al  
    46 000000B8 B9FFFFFFFF                  mov     ecx, 0xffffffff
    47                                  
    48 000000BD F2AE                        repne   scasb   ; while [edi] != al
    49                                  
    50 000000BF 29DF                        sub     edi, ebx     
    51 000000C1 89F8                        mov     eax, edi     
    52 000000C3 48                          dec eax
    53                                  
    54 000000C4 C3                          ret         
    55                                  ; end of strlen 
    56                                  
    57                                  ;------------------------------------------------
    58                                  ; PRINTF
    59                                  ; 
    60                                  ; CHANGED: esi, eax, dl, ecx (ret), ebx
    61                                  ;------------------------------------------------
    62                                  printf:
    63                                      ; si is where we read string
    64 000000C5 59                          pop     ecx
    65 000000C6 890D[30000000]              mov     [ret_addr], ecx
    66 000000CC 5E                          pop     esi
    67 000000CD 89F7                        mov     edi, esi
    68 000000CF 4E                          dec     esi      ; useful because you do not need to inc it befoure calling loop
    69                                  
    70                                      .printf_loop:
    71 000000D0 46                              inc     esi
    72 000000D1 8A06                            mov     al, [esi]
    73 000000D3 3C25                            cmp     al, '%'
    74 000000D5 742D                            je      .codes
    75                                  
    76 000000D7 3C00                            cmp     al, 0
    77 000000D9 7417                            je      .ret
    78                                  
    79                                          WRITE   esi, 1
     9                              <1> 
    10 000000DB 6A00                <1>  push dword 0
    11 000000DD 68[00000000]        <1>  push numCharsWritten
    12 000000E2 6A01                <1>  push dword %2
    13 000000E4 56                  <1>  push dword %1
    14 000000E5 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000000EB E8(00000000)        <1>  call WriteConsoleA
    80                                          
    81 000000F0 EBDE                            jmp     .printf_loop
    82                                  
    83                                  .ret:
    84 000000F2 8B0D[30000000]              mov     ecx, [ret_addr]
    85 000000F8 51                          push    ecx
    86 000000F9 C3                          ret
    87                                  
    88                                  .jmp_percent:
    89 000000FA E98D010000                  jmp     .percent
    90                                  
    91                                  .jmp_default:
    92 000000FF E9AD010000                  jmp     .default
    93                                  
    94                                  .codes:
    95 00000104 46                          inc     esi
    96 00000105 8A06                        mov     al, [esi]
    97                                  
    98 00000107 3C25                        cmp     al, '%'
    99 00000109 74EF                        je      .jmp_percent
   100 0000010B 3C62                        cmp     al, 'b'
   101 0000010D 7CF0                        jl      .jmp_default    ; less than 'b'
   102 0000010F 3C78                        cmp     al, 'x'
   103 00000111 7FEC                        jg      .jmp_default    ; more than 'x'
   104                                  
   105 00000113 2C62                        sub     al, 'b'
   106 00000115 31DB                        xor     ebx, ebx
   107 00000117 88C3                        mov     bl, al
   108                                      ; ebx = 4*al
   109 00000119 01DB                        add     ebx, ebx
   110 0000011B 01DB                        add     ebx, ebx
   111                                  
   112 0000011D 8B9B[25010000]              mov     ebx, [ebx + .jmp_table]
   113 00000123 FFE3                        jmp     ebx
   114                                  
   115                                  .jmp_table:
   116                                      ; hardcoded jmp table
   117 00000125 [B0010000]                  dd      .bin 
   118 00000129 [43020000]                  dd      .char
   119 0000012D [81010000]                  dd      .dec
   120 00000131 [B1020000]-                 dd      10 dup(.default)
   120 00000135 [B1020000]-        
   120 00000139 [B1020000]-        
   120 0000013D [B1020000]-        
   120 00000141 [B1020000]-        
   120 00000145 [B1020000]-        
   120 00000149 [B1020000]-        
   120 0000014D [B1020000]-        
   120 00000151 [B1020000]-        
   120 00000155 [B1020000]         
   121 00000159 [E1010000]                  dd      .oct
   122 0000015D [B1020000]-                 dd      3 dup(.default)
   122 00000161 [B1020000]-        
   122 00000165 [B1020000]         
   123 00000169 [67020000]                  dd      .str
   124 0000016D [B1020000]-                 dd      4 dup(.default)
   124 00000171 [B1020000]-        
   124 00000175 [B1020000]-        
   124 00000179 [B1020000]         
   125 0000017D [12020000]                  dd      .hex
   126                                  
   127                                  .dec:
   128 00000181 58                          pop     eax
   129 00000182 56                          push    esi
   130                                  
   131 00000183 BF[08000000]                mov     edi, itoaBuff
   132 00000188 B90A000000                  mov     ecx, 10
   133 0000018D E86EFEFFFF                  call    itoa
   134                                  
   135 00000192 5E                          pop     esi
   136                                  
   137                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000193 6A00                <1>  push dword 0
    11 00000195 68[00000000]        <1>  push numCharsWritten
    12 0000019A 50                  <1>  push dword %2
    13 0000019B 68[08000000]        <1>  push dword %1
    14 000001A0 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001A6 E8(00000000)        <1>  call WriteConsoleA
   138 000001AB E920FFFFFF                  jmp     .printf_loop
   139                                  
   140                                  .bin:
   141 000001B0 58                          pop     eax
   142 000001B1 56                          push    esi
   143                                  
   144 000001B2 BF[08000000]                mov     edi, itoaBuff
   145 000001B7 B901000000                  mov     ecx, 1
   146 000001BC 30FF                        xor     bh, bh
   147 000001BE E889FEFFFF                  call    itoa2n
   148                                  
   149 000001C3 5E                          pop     esi
   150                                  
   151                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001C4 6A00                <1>  push dword 0
    11 000001C6 68[00000000]        <1>  push numCharsWritten
    12 000001CB 50                  <1>  push dword %2
    13 000001CC 68[08000000]        <1>  push dword %1
    14 000001D1 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000001D7 E8(00000000)        <1>  call WriteConsoleA
   152 000001DC E9EFFEFFFF                  jmp     .printf_loop
   153                                  
   154                                  .oct:
   155 000001E1 58                          pop     eax
   156 000001E2 56                          push    esi
   157                                  
   158 000001E3 BF[08000000]                mov     edi, itoaBuff
   159 000001E8 B903000000                  mov     ecx, 3
   160 000001ED 30FF                        xor     bh, bh
   161 000001EF E858FEFFFF                  call    itoa2n
   162                                  
   163 000001F4 5E                          pop     esi
   164                                  
   165                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 000001F5 6A00                <1>  push dword 0
    11 000001F7 68[00000000]        <1>  push numCharsWritten
    12 000001FC 50                  <1>  push dword %2
    13 000001FD 68[08000000]        <1>  push dword %1
    14 00000202 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000208 E8(00000000)        <1>  call WriteConsoleA
   166 0000020D E9BEFEFFFF                  jmp     .printf_loop
   167                                  
   168                                  .hex:
   169 00000212 58                          pop     eax
   170 00000213 56                          push    esi
   171                                  
   172 00000214 BF[08000000]                mov     edi, itoaBuff
   173 00000219 B904000000                  mov     ecx, 4
   174 0000021E 30FF                        xor     bh, bh
   175 00000220 E827FEFFFF                  call    itoa2n
   176                                  
   177 00000225 5E                          pop     esi
   178                                  
   179                                      WRITE   itoaBuff, eax
     9                              <1> 
    10 00000226 6A00                <1>  push dword 0
    11 00000228 68[00000000]        <1>  push numCharsWritten
    12 0000022D 50                  <1>  push dword %2
    13 0000022E 68[08000000]        <1>  push dword %1
    14 00000233 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000239 E8(00000000)        <1>  call WriteConsoleA
   180 0000023E E98DFEFFFF                  jmp     .printf_loop
   181                                  
   182                                  .char:
   183 00000243 58                          pop     eax
   184 00000244 A2[08000000]                mov     [itoaBuff], al
   185                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 00000249 6A00                <1>  push dword 0
    11 0000024B 68[00000000]        <1>  push numCharsWritten
    12 00000250 6A01                <1>  push dword %2
    13 00000252 68[08000000]        <1>  push dword %1
    14 00000257 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 0000025D E8(00000000)        <1>  call WriteConsoleA
   186 00000262 E969FEFFFF                  jmp     .printf_loop
   187                                  
   188                                  .str:
   189 00000267 58                          pop     eax
   190 00000268 56                          push    esi
   191                                  
   192 00000269 89C6                        mov     esi, eax
   193 0000026B 89C7                        mov     edi, eax
   194 0000026D E842FEFFFF                  call    strlen
   195                                  
   196                                      WRITE   esi, eax
     9                              <1> 
    10 00000272 6A00                <1>  push dword 0
    11 00000274 68[00000000]        <1>  push numCharsWritten
    12 00000279 50                  <1>  push dword %2
    13 0000027A 56                  <1>  push dword %1
    14 0000027B FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 00000281 E8(00000000)        <1>  call WriteConsoleA
   197                                  
   198 00000286 5E                          pop     esi
   199                                  
   200 00000287 E944FEFFFF                  jmp     .printf_loop
   201                                  
   202                                  .percent:
   203 0000028C C605[08000000]25            mov     byte [itoaBuff], '%'
   204                                      WRITE   itoaBuff, 1
     9                              <1> 
    10 00000293 6A00                <1>  push dword 0
    11 00000295 68[00000000]        <1>  push numCharsWritten
    12 0000029A 6A01                <1>  push dword %2
    13 0000029C 68[08000000]        <1>  push dword %1
    14 000002A1 FF35[04000000]      <1>  push dword [STDOutputHandle]
    15 000002A7 E8(00000000)        <1>  call WriteConsoleA
   205 000002AC E91FFEFFFF                  jmp     .printf_loop
   206                                  
   207                                  .default:
   208 000002B1 E91AFEFFFF                  jmp     .printf_loop
   209                                  
   210                                  ; end of printf
   211                                  
   212                                  _start:
   213                                  
   214                                      ; GetStdHandle( STD_OUTPUT_HANDLE )
   215 000002B6 6AF5                        push    dword -11
   216 000002B8 E8(00000000)                call    GetStdHandle ; returns in eax
   217 000002BD A3[04000000]                mov     [STDOutputHandle], eax
   218                                  
   219 000002C2 6A11                        push    dword 17
   220 000002C4 68DE000000                  push    dword 0DEh
   221 000002C9 68[2F030000]                push    dword  str_wr
   222 000002CE 6A6A                        push    dword 'j'
   223 000002D0 6A06                        push    dword 6
   224 000002D2 6841050000                  push    dword 1345
   225 000002D7 68[E8020000]                push    dword  str_to_printf
   226 000002DC E8E4FDFFFF                  call    printf
   227                                  
   228                                      ; ExitProcess( 0 )
   229 000002E1 6A00                        push    dword 0   
   230 000002E3 E8(00000000)                call    ExitProcess
   231                                  
   232 000002E8 5052494E5446464646-         str_to_printf db "PRINTFFFF %d was not %b and %c so it is %s and %x but not %o (not 0)", 10, "a", 0
   232 000002F1 20256420776173206E-
   232 000002FA 6F7420256220616E64-
   232 00000303 20256320736F206974-
   232 0000030C 20697320257320616E-
   232 00000315 642025782062757420-
   232 0000031E 6E6F7420256F20286E-
   232 00000327 6F742030290A6100   
   233 0000032F 736F6D652073747200          str_wr        db "some str", 0
   234                                  
   235 00000338 4445420A00                  DEBSTR db "DEB", 10, 0
